#include "PlayGround.h"
#include"Racket.h"
#include"Ball.h"
#include"Item.h"
#include"Brick.h"
#include"ArrayBrick.h"
#include<stdlib.h>
#include<time.h>
#include<random>
#include<math.h>
#include<MMsystem.h>
#include<Windows.h>
#include<dos.h>


#define Column 6 //cột
#define Row 3   //hàng


// window size and update rate (60 fps)
int width = 1000;
int height = 500;
int interval = 1000 / 60;

int level = 1;

// score
int score_left = 0;
int score_right = 0;
int score = 18;

/*Khởi tạo các object*/
Racket racket1;
Racket racket2;
Racket racket_1_character;
Ball ball;
Enermy enermy;
Item item;
Brick brick[Row][Column];

//ArrayBrick *a = new ArrayBrick(Row, Column);
//Brick** brick = a->GetArr();


void enable2D(int width, int height) {
	glViewport(0, 0, width, height);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(0.0f, width, 0.0f, height, 0.0f, 1.0f);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
}


/*in văn bản ra màn hình*/
void drawText(float x, float y, std::string text) {
	glRasterPos2f(x, y);
	glutBitmapString(GLUT_BITMAP_8_BY_13, (const unsigned char*)text.c_str());
}

/*Đổi số nguyên thành ký tự và giữ nguyên giá trị*/
std::string int2str(int x) {
	// converts int to string
	std::stringstream ss;
	ss << x;
	return ss.str();
}

void draw() {

	// clear (has to be done at the beginning)
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glLoadIdentity();

	//// ToDo: draw our scene

	/// draw ball
	//ball.drawRect(ball.get_ball_pos_x() - ball.get_ball_size() / 2, ball.get_ball_pos_y() - ball.get_ball_size() / 2, ball.get_ball_size(), ball.get_ball_size());
	//// draw ball (easy version, but not entirely centered)
	ball.drawRect(ball.get_ball_pos_x(), ball.get_ball_pos_y(), ball.get_ball_size(), ball.get_ball_size());

	//// draw rackets
	racket1.drawRect(racket1.get_racket_left_x(), racket1.get_racket_left_y(), racket1.get_racket_width(), racket1.get_racket_height());
	racket2.drawRect(racket2.get_racket_right_x(), racket2.get_racket_right_y(), racket2.get_racket_width(), racket1.get_racket_height());

	//draw item
	//item.drawCircle(400, 150);
	item.drawRect(item.get_item_pos_x(), item.get_item_pos_y(), item.get_item_size(), item.get_item_size());

	// draw score
	drawText(width / 2 - 30, height - 30, int2str(score_left) + ":" + int2str(score_right));
	drawText(30, height - 30, "SPACE: PAUSE");
	drawText(30, height - 50, "ENTER: CONTINUE");
	drawText(width - 140, height - 30, "ESC   : STOP");
	drawText(width - 140, height - 50, "F1   : RESULT");

	if (GetAsyncKeyState(VK_F1))   //Nhấn nút F1 để xuất kết quả
	{
		system("pause");
		if (score_left > score_right)
		{
			drawText(width / 2 - 70, height / 2, "LEFT PLAYER WIN!");
		}
		else if (score_left > score_right)
		{
			drawText(width / 2 - 70, height / 2, "RIGHT PLAYER WIN!");
		}
	}

	//draw Enermy
	enermy.drawRect(enermy.get_enermy_pos_x(), enermy.get_enermy_pos_y(), enermy.get_enermy_width(), enermy.get_enermy_height());
	//ball.updateBall(racket1, racket2, score_left, score_right, enermy);


	// swap buffers (has to be done at the end)
	glutSwapBuffers();
}


void update(int value) {
	// input handling
	racket1.keyboard1();
	racket2.keyboard2();

	// update ball
	ball.updateBall(racket1, racket2, score_left, score_right, enermy, item);

	if (GetAsyncKeyState(VK_SPACE))    //nhấp nút SPACE để tạm dừng, nhấn Enter để tiếp tục
	{
		system("pause");
	}

	if (GetAsyncKeyState(VK_ESCAPE))    //nhấp nút SPACE để tạm dừng, nhấn Enter để tiếp tục
	{
		exit(0);
	}

	// Call update() again in 'interval' milliseconds
	glutTimerFunc(interval, update, 0);

	// Redisplay frame
	glutPostRedisplay();
}


bool WinOrLose()
{
	int dem = 0;
	for (int i = 0; i < Row; i++)
	{
		for (int j = 0; j < Column; j++)
		{
			if (brick[i][j].get_exist() == 1)
			{
				dem++;
			}
		}
	}
	if (dem == 0)
	{
		return true;
	}
	else
	{
		return false;
	}
}


void draw1() {

	// clear (has to be done at the beginning)
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glLoadIdentity();

	//draw racket
	int w = 150;  //Độ rộng thanh ngang
	int h = 10;   //Độ dày thanh ngang
	racket_1_character.set_racket_width(w);
	racket_1_character.set_racket_height(h);
	racket_1_character.drawRect(racket_1_character.get_racket_x(), racket_1_character.get_racket_y(), racket_1_character.get_racket_width(), racket_1_character.get_racket_height());

	//draw ball
	//float y = racket_1_character.get_racket_height() ;
	//ball.set_ball_pos_y(y);
	ball.drawRect(ball.get_ball_pos_x(), ball.get_ball_pos_y(), ball.get_ball_size(), ball.get_ball_size());

	drawText(20, height - 30, "SPACE: RESUME");
	drawText(width - 110, height - 30, "F1: PAUSE");
	drawText(20, height - 50, "ESC: STOP");

	//draw brick
	//brick.drawRect(20, 460, 150, 20);
	int i, j;
	int x, y;
	x = 20;
	y = 420;
	for (i = 0; i < Row; i++)
	{
		for (j = 0; j < Column; j++)
		{
			brick[i][j].drawRect(x, y, brick[i][j].get_brick_width(), brick[i][j].get_brick_height());
			brick[i][j].set_brick_pos_x(x);
			brick[i][j].set_brick_pos_y(y);
			x += 160;
		}
		y -= 30;
		x = 20;
	}


	if (WinOrLose() == true)
	{
		drawText(width / 2 - 70, height / 2, "PLAYER WIN!");
		//exit(1);
		//system("pause");	
		_getch();
	}
	cout << level << endl;

	//draw enermy
	if (level == 4 || level == 4)
	{
		enermy.set_enermy_width(150);
		enermy.set_enermy_height(20);
		float pos_y = 330;
		enermy.set_enermy_pos_y(pos_y);
		enermy.drawRect(enermy.get_enermy_pos_x(), enermy.get_enermy_pos_y(), enermy.get_enermy_width(), enermy.get_enermy_height());
	}


	// swap buffers (has to be done at the end)
	glutSwapBuffers();
}


void update1(int value) {


	racket_1_character.keyboardfor1character();

	ball.updateBallfor1character(racket_1_character, enermy, level);

	int i, j;
	for (i = 0; i < Row; i++)
	{
		for (j = 0; j < Column; j++)
		{
			brick[i][j].updateBrick(ball, level);
		}
	}

	if (GetAsyncKeyState(VK_F1))    //nhấp nút SPACE để tạm dừng, nhấn Enter để tiếp tục
	{
		system("pause");
		//_getch();
	}
	if (GetAsyncKeyState(VK_ESCAPE))    //nhấp nút SPACE để tạm dừng, nhấn Enter để tiếp tục
	{
		exit(0);
	}

	// Call update() again in 'interval' milliseconds
	glutTimerFunc(interval, update1, 0);

	// Redisplay frame
	glutPostRedisplay();
}



// program entry point
int main(int argc, char** argv)
{
	//PlaySound(TEXT("ChooseAChocobo-V.A-3316579.wav"), NULL, SND_ASYNC);
	int lc = 0;
	while (1)
	{
		cout << "Chon chuc nang: ";
		cout << "\n  1:Choi game";
		cout << "\n  2:Thoat";
		cout << "\n  Chuc nang: ";
		cin >> lc;
		if (lc == 1)  //Bắt đầu chơi game và vẽ trên console
		{
			cout << "0. Thoat/1. 1 nguoi choi/2. 2 nguoi choi\n";
			int nguoichoi;
			cin >> nguoichoi;
			if (nguoichoi == 2)
			{
				// initialize opengl (via glut)
				glutInit(&argc, argv);
				glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
				glutInitWindowSize(width, height);
				glutCreateWindow("2 NGUOI CHOI!");

				// Register callback functions  
				glutDisplayFunc(draw);
				glutTimerFunc(interval, update, 0);

				// setup scene to 2d mode and set draw color to white
				enable2D(width, height);
				glColor3f(1.0f, 1.0f, 1.0f);  //chỉnh màu nền

				// start the whole thing
				glutMainLoop();
			}

			if (nguoichoi == 1)
			{
				while (level >= 1 && level <= 4)
				{
					/*cout << "Lua chon level ban muon choi [1->4]:";
					cin >> level;*/
					// initialize opengl (via glut)

					if (level == 1)
					{
						glutInit(&argc, argv);
						glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
						glutInitWindowSize(width, height);
						glutCreateWindow("1 NGUOI CHOI - LEVEL 1!");
						// Register callback functions 

						glutDisplayFunc(draw1);
						glutTimerFunc(interval, update1, 0);

						// setup scene to 2d mode and set draw color to white
						enable2D(width, height);
						//glColor3f(1.0f, 1.0f, 1.0f);  //chỉnh màu nền

						// start the whole thing
						glutMainLoop();
					}
					if (level == 2)
					{
						glutInit(&argc, argv);
						glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
						glutInitWindowSize(width, height);
						glutCreateWindow("1 NGUOI CHOI - LEVEL 2!");
						// Register callback functions 

						glutDisplayFunc(draw1);
						glutTimerFunc(interval, update1, 0);

						// setup scene to 2d mode and set draw color to white
						enable2D(width, height);
						//glColor3f(1.0f, 1.0f, 1.0f);  //chỉnh màu nền

						// start the whole thing
						glutMainLoop();
					}
					if (level == 3)
					{
						glutInit(&argc, argv);
						glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
						glutInitWindowSize(width, height);
						glutCreateWindow("1 NGUOI CHOI - LEVEL 3!");
						// Register callback functions 

						glutDisplayFunc(draw1);
						glutTimerFunc(interval, update1, 0);

						// setup scene to 2d mode and set draw color to white
						enable2D(width, height);
						//glColor3f(1.0f, 1.0f, 1.0f);  //chỉnh màu nền

						// start the whole thing
						glutMainLoop();
					}
					if (level == 4)
					{
						glutInit(&argc, argv);
						glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
						glutInitWindowSize(width, height);
						glutCreateWindow("1 NGUOI CHOI - LEVEL 4!");
						// Register callback functions 

						glutDisplayFunc(draw1);
						glutTimerFunc(interval, update1, 0);

						// setup scene to 2d mode and set draw color to white
						enable2D(width, height);
						//glColor3f(1.0f, 1.0f, 1.0f);  //chỉnh màu nền

						// start the whole thing
						glutMainLoop();
					}
					level++;
				}
			}
		}
		if (lc == 2)
		{
			cout << "Cam on ban da choi";
			break;
		}
	}

	return 0;
}


